<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[2.Add Two Numbers]]></title>
      <url>/2017/08/13/Leetcode-2-Add-Two-Numbers/</url>
      <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><blockquote>
<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
</blockquote>
<p>LeetCode link: <a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="external">Add Two Numbers</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">        ListNode l = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode start = l;</div><div class="line">        <span class="keyword">int</span> nVal = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> l1Val = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</div><div class="line">            <span class="keyword">int</span> l2Val = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</div><div class="line">            </div><div class="line">            <span class="keyword">int</span> val = (l1Val + l2Val + nVal) % <span class="number">10</span>;</div><div class="line">            nVal = (l1Val + l2Val + nVal) / <span class="number">10</span>;</div><div class="line">            </div><div class="line">            start.next = <span class="keyword">new</span> ListNode(val);</div><div class="line">            start = start.next;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</div><div class="line">                l1 = l1.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</div><div class="line">                l2 = l2.next;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (nVal &gt; <span class="number">0</span>) &#123;</div><div class="line">            start.next = <span class="keyword">new</span> ListNode(nVal);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> l.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode刷题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[半年提升学习规划（201706-201801）]]></title>
      <url>/2017/06/22/%E5%8D%8A%E5%B9%B4%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%88201706-201801%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="201706-201801"><a href="#201706-201801" class="headerlink" title="201706-201801"></a>201706-201801</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>Leetcode算法系列</li>
<li>github</li>
</ul>
<h2 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h2><ul>
<li>完成Leetcode算法系列博客</li>
<li>完成Java学习系列笔记</li>
<li>完成Php学习系列笔记<ul>
<li>目标：完成php扩展开发及扩展开发系列教程</li>
</ul>
</li>
<li>机器学习算法学习与实战系列</li>
</ul>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><ul>
<li>机器学习实战</li>
</ul>
<h2 id="技术实战"><a href="#技术实战" class="headerlink" title="技术实战"></a>技术实战</h2><ul>
<li>秒杀系统设计与实现方案（Java/Php）</li>
</ul>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> 技术规划 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[高并发秒杀系统设计探讨]]></title>
      <url>/2017/06/22/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8E%A2%E8%AE%A8/</url>
      <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://my.oschina.net/xianggao/blog/524943" target="_blank" rel="external">https://my.oschina.net/xianggao/blog/524943</a></li>
</ul>
<a id="more"></a>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[算法学习-DP之动态规划]]></title>
      <url>/2017/06/14/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-DP%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.hawstein.com/posts/dp-novice-to-advanced.html" target="_blank" rel="external">http://www.hawstein.com/posts/dp-novice-to-advanced.html</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/amazing-priority-array.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/easy-learn-algorithm/amazing-priority-array.html</a></li>
</ol>
<a id="more"></a>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL数据库索引详解及查询优化]]></title>
      <url>/2017/06/14/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></li>
<li><a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external">http://tech.meituan.com/mysql-index.html</a></li>
</ol>
<a id="more"></a>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo Minos主题优化]]></title>
      <url>/2017/05/05/Hexo-Minos%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="Tags-Categories页面无法显示问题"><a href="#Tags-Categories页面无法显示问题" class="headerlink" title="Tags/Categories页面无法显示问题"></a>Tags/Categories页面无法显示问题</h3><ul>
<li>解决方法：</li>
</ul>
<p>在生成的<code>source/tags/index.md</code>中加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layout: tag // 引用theme下的layout中tag.ejs</div></pre></td></tr></table></figure></p>
<p>以及<code>source/categories/index.md</code>中加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layout: categories // 引用theme下的layout中category.ejs</div></pre></td></tr></table></figure></p>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Minos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[培养你的人生观]]></title>
      <url>/2017/04/07/%E5%9F%B9%E5%85%BB%E4%BD%A0%E7%9A%84%E4%BA%BA%E7%94%9F%E8%A7%82/</url>
      <content type="html"><![CDATA[<p></p><p><b>一、社会、人类</b></p><ol><li>《人类简史》[以色列]尤瓦尔·赫拉利 （一部世界史竟然能够畅销，确实不容易，据说微信之父张小龙也很推荐）</li><li>《人类学透镜》詹姆斯·皮科克（入门书籍）</li><li>《社会学入门》詹姆斯·汉斯林（都说是入门了，给你一个更宽广的视角吧）</li><li>《论人类不平等的起源》卢梭（不介绍了，经典书籍）</li><li>《功利主义》穆勒（这里的功利主义真和我们生活中常说的功利不一样）</li><li>《1984》、《动物庄园》不解释，细思极恐。</li><li>《自私的美德》安.兰德（ 作者力倡个人主义，认为不能使个人利益得到最大伸张的社会，就不是理想社会，我觉得在我们国情下尤其具有启发意义。 ）</li></ol><p><b>二、心理</b></p><ol><li>《社会心理学》戴维迈尔斯（社会心理学最好的作品，我觉得没有之一）</li><li>《爱的艺术》弗洛姆（网友评价：书薄，但是分量重）</li><li>《心灵简史》[英]乔治·汉弗瑞等（心灵成长的通俗诠释，可读，易读）</li><li>《进化心理学》巴斯（读完对婚姻和择偶有更深的认知）</li><li>《亲密关系》莎伦.布雷姆（和上一本搭配着看，有意思）</li><li>《乌合之众》勒庞（深有感触，前几天发个帖后来受不住评论删除内容了）</li><li>《非暴力沟通》（应@子曰要求添加。舌头不是铁，却能砸死人，别老自诩豆腐心、刀子嘴了，这样其实不好）</li></ol><p><a id="more"></a> <b>三、文化</b></p><ol><li>《中国文化的深层结构》孙隆基（可能不是很好读，我读了几遍）</li><li>《素书》（据传是黄石公所做，没做考证，但我觉得很好，耐心品味）</li><li>《菜根谭》洪应明（中国传统文化还是有很多不错的，不过少部分内容辩证看待吧）</li><li>《智慧书》巴尔塔沙·葛拉西安（一本小册子，据说曾经风靡欧洲，还是要自己悟吧）</li><li>《人情与面子》黄光国（对于中国人际关系的划分是经典）</li><li>《权经》冯道（ 五代十国的传奇人物,一生历经五朝十二帝,可谓真正的官场不倒翁 ）</li></ol><p><b>四、思维</b></p><ol><li>《超越感觉：批判性思考指南》文森特•鲁吉罗（批判性思考，个人最提倡的）</li><li>《尼采的锤子》[英]尼古拉斯·费恩（小故事中有哲理，我觉得挺有趣的）</li><li>《思考的力量》理查德保罗（个人非常喜欢的一本，但是有点晦涩，需要耐心）</li><li>《像心理学家一样思考》[美] 唐纳德·麦克伯尼（相对浅显，易读）</li><li>《我们如何思维》约翰杜威（实用主义的典型代表杜威，理论和干货多）</li><li>《有效思维》[英] L. S. 斯泰宾（读的人应该不多，我印象最深的是有关自我中心主义）</li><li>《身边的逻辑学》伯纳·派顿（前面几章看的很爽，后面好像印象较浅）</li></ol><p><b>五、教育</b></p><ol><li>《如何成为卓越的大学教师》肯·贝恩（推荐中国的大学老师好好读，好多大学老师是不合格的）</li><li>《给教师的建议》[苏] B.A. 苏霍姆林斯基（教育界有人说话必称“苏霍姆林斯基说过…所以，不解释，推荐所有老师看）</li><li>《光有爱还不够》克洛德·阿尔莫（真正的父母之爱，是帮助孩子构建自我。）</li><li>《教学设计原理》加涅（老师、培训师建议看，课程设计与开发经典之作）</li><li>《民主·经验·教育》约翰杜威（杜威，大牛，不解释）</li></ol><p><b>六、职业发展和求职</b></p><ol><li>《把时间当朋友》李笑来（文字浅显易懂，真诚不造作）</li><li>《适合比成功更重要》[美] 布朗温•卢埃林（有测评，不过仅供参考）</li><li>《快乐富有过一生》汉斯·雅各比（个人认为观念上的引导还是不错的）</li><li>《聘之有道面试读心术》王新宇（看看企业招人的逻辑、逆向思考）</li><li>《金字塔原理：思考、写作和解决问题的逻辑》[美] 巴巴拉·明托</li></ol><p></p>
]]></content>
      
        <categories>
            
            <category> 生活感悟 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 人生观 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis SortedSet多字段排序拉链设计]]></title>
      <url>/2017/03/07/Redis%20SortedSet%E5%A4%9A%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F%E6%8B%89%E9%93%BE%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h2 id="应用场景描述"><a href="#应用场景描述" class="headerlink" title="应用场景描述"></a>应用场景描述</h2><blockquote>
<p>pb热门回复列表，规则为按照三个字段综合排序(优先按照点赞数排序、其次按照楼中楼数排序、最后按照最后回复时间排序)：</p>
<ul>
<li>回复点赞数<code>agree_num</code></li>
<li>回复楼中楼数<code>comment_num</code></li>
<li>回复的楼中楼最后回复时间<code>last_reply_time</code></li>
</ul>
</blockquote>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>这里探讨的主要有两种实现方案：</p>
<ul>
<li>方案一：使用<code>DB/DDBS</code>的<code>order by</code> 多级字段排序；</li>
<li>方案二：<code>redis</code>的SortedSet提供类排行榜实现，底层使用skip list，排序和查询时间复杂度较低；</li>
</ul>
<a id="more"></a>
<p>优缺点分析：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>方案一</td>
<td>代码实现简单</td>
<td>1、数据量膨胀后性能迅速降低<br>2、 不支持高并发场景<br>3、写qps较高时重建索引对性能损耗较大</td>
</tr>
<tr>
<td>方案二</td>
<td>1、查询时间复杂度为O(log(n))，耗时稳定 <br>2、内存型存储，支持较高qps</td>
<td>占用redis集群内存资源</td>
</tr>
</tbody>
</table>
<h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><p>Sorted set底层基于跳跃表实现，查询的时间复杂度在O(log(n))。</p>
<p>Redis中的SortedSet根据score的64位双精度浮点数的参数实现排序，可以表示浮点数或整数类型，作为浮点数score的取值范围为54位， 但是在实际应用中推荐将score当做64位长整型来使用。</p>
<p>原因很简单: long的取值范围要大于double。</p>
<blockquote>
<p>long范围为[-(2^53), +(2^53)]，double范围为[-(2^63), +(2^63)-1]</p>
</blockquote>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="设计探讨"><a href="#设计探讨" class="headerlink" title="设计探讨"></a>设计探讨</h3><p>由于需要使用三个字段（<code>agree_num/comment_num/last_reply_time</code>）作为排序依据，所以如何把3个字段合并为1个字段计入score，是解决问题的关键。</p>
<p>当score作为<code>64bit</code>长整型使用时，我们假设前提约束条件（楼层点赞数小于20万、楼中楼数小于20万）：</p>
<blockquote>
<p><code>agree_num</code> &lt;= 2097151 (2^21-1)<br><code>comment_num</code> &lt;= 4194303(2^22-1)</p>
</blockquote>
<p>这样<code>agree_num</code>和<code>comment_num</code>总共需要占用<em>44bit</em>，<code>last_reply_time</code>字段只有<em>20bit</em> 可用。</p>
<p>但根据unix时间戳（精确到s），10位数字时间戳最大值至少需要<em>33bit</em>存储，关键问题转为如何优化时间戳的存储。</p>
<h3 id="存储方案"><a href="#存储方案" class="headerlink" title="存储方案"></a>存储方案</h3><p>和业务pm沟通之后，产品上可以接受按回复时间排序时只精确到天级别，那么我们可以根据unix时间戳得到日期，如<code>20170329</code>，更极致的做法是将年份前两位<code>20</code>也去掉，只保留<code>170329</code>，10进制6位数字恰好使用<em>20bit</em>可以满足存储需求。</p>
<h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><p>由于热门回复的排序逻辑中三个字段有不同的优先级，我们最先想到的实现方案是按bit位分割，优先级高的字段占据较高的bit段，优先级低的字段在较低的bit段。</p>
<p>在64位机器下，php integer类型取值范围为<em>[-(2^63, +2^63-1]</em>，而热门回复的三个排序字段占位已优化为：</p>
<blockquote>
<p><code>agree_num</code> 22bit<br><code>comment_num</code> 22bit<br><code>last_reply_time</code> 20bit</p>
</blockquote>
<p>所以设置Sorted set的score实现代码就很简单了：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$score = (int)$agree_num &lt;&lt; <span class="number">42</span> | (int)$comment_num &lt;&lt; <span class="number">20</span> | (int)$dayOfDate;</div><div class="line">$arrReq = <span class="keyword">array</span>(</div><div class="line">    <span class="string">'key'</span> =&gt; <span class="keyword">self</span>::REDIS_KEY_PREFIX. $arrInput[<span class="string">'thread_id'</span>],</div><div class="line">    <span class="string">'members'</span> =&gt; <span class="keyword">array</span>(</div><div class="line">        <span class="keyword">array</span>(</div><div class="line">            <span class="string">'score'</span> =&gt; $redisScore,</div><div class="line">            <span class="string">'member'</span> =&gt; $arrInput[<span class="string">'post_id'</span>],</div><div class="line">        ),</div><div class="line">    ),</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>实现思路：<code>agree_num</code>左移<em>42bit</em>，占位最高<em>22bit</em>，<code>comment_num</code>左移<em>20bit</em>，占位中间<em>22bit</em>，<code>dayOfDate</code>占位最低<em>20bit</em>。</p>
<p>ps: 如何根据score获取原字段值？<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$agree_num = $score &gt;&gt; <span class="number">42</span>;</div><div class="line">$comment_num = $score &gt;&gt; <span class="number">20</span> &amp; ~(PHP_INT_MAX &lt;&lt; <span class="number">20</span>);</div><div class="line">$dayOfDate= $score &amp; ~(PHP_INT_MAX &lt;&lt; <span class="number">20</span>);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>完美~</p>
</blockquote>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>暂无</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://redis.io/topics/indexes" target="_blank" rel="external">https://redis.io/topics/indexes</a></li>
<li><a href="http://php.net/manual/zh/language.types.integer.php" target="_blank" rel="external">http://php.net/manual/zh/language.types.integer.php</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP多字节字符串截取方法]]></title>
      <url>/2016/11/07/php%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>PHP的substr()方法多用于截取英文等单字节文件，对于中文字符串通常会返回各种乱码，多字节字符串（中文）在不同编码下的占用字节不同，针对这种情况，下面给出一个参考实现，需要的同学根据自己的需求可以在此基础上修改：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 多字节字符串截断方法</div><div class="line"> * <span class="doctag">@param</span> $str 原始字符串</div><div class="line"> * <span class="doctag">@param</span> $start 起始位置，多字节字符长度视为1</div><div class="line"> * <span class="doctag">@param</span> $len 长度，多字节字符长度视为1</div><div class="line"> * <span class="doctag">@param</span> string $charset 原始字符串编码</div><div class="line"> * <span class="doctag">@return</span> string 处理后字符串</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mb_substr</span><span class="params">($str, $start, $len, $charset = <span class="string">'utf8'</span>)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ($charset == <span class="string">'utf8'</span> || $charset == <span class="string">'utf-8'</span>) &#123;</div><div class="line">	    $mb_step = <span class="number">3</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">	    $mb_step = <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 字符串字节长度</span></div><div class="line">    $str_len = strlen($str);</div><div class="line"></div><div class="line">    <span class="comment">// 字节偏移量</span></div><div class="line">    $offset = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $start; $i++)</div><div class="line">    &#123;</div><div class="line">	    <span class="keyword">if</span> ($offset &gt;= $str_len) <span class="keyword">break</span>;</div><div class="line">	    $char = ord($str[$offset]);</div><div class="line">	    <span class="keyword">if</span>($char &lt;= <span class="number">0x7F</span>) &#123;</div><div class="line">		    $offset++;</div><div class="line">	    &#125; <span class="keyword">else</span> &#123;</div><div class="line">		    $offset += $mb_step;</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 字节长度</span></div><div class="line">    $mb_len = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $len; $i++)</div><div class="line">    &#123;</div><div class="line">	    <span class="keyword">if</span> ($offset+$mb_len &gt;= $str_len) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">	    $char = ord($str[$offset+$mb_len]);</div><div class="line">	    <span class="keyword">if</span>($char &lt;= <span class="number">0x7F</span>) &#123;</div><div class="line">		    $mb_len++;</div><div class="line">	    &#125; <span class="keyword">else</span> &#123;</div><div class="line">		    $mb_len += $mb_step;</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 截取字符串</span></div><div class="line">    <span class="keyword">return</span> substr($str, $offset, $mb_len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> 技术总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XMLHttpRequest接口FormData异步上传文件]]></title>
      <url>/2016/11/06/XMLHttpRequest%E6%8E%A5%E5%8F%A3FormData%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<blockquote>
<p><code>XMLHttpRequest Level 2</code>添加了一个新的接口<code>FormData</code>。利用<code>FormData</code>对象，我们可以通过JavaScript用一些键值对来模拟一系列表单控件，我们还可以使用<code>XMLHttpRequest</code>的<code>send()</code>方法来异步的提交这个表单。比起普通的ajax，使用<code>FormData</code>的最大优点就是我们可以异步上传一个二进制文件。</p>
</blockquote>
<h2 id="创建FormData对象"><a href="#创建FormData对象" class="headerlink" title="创建FormData对象"></a>创建FormData对象</h2><p>利用FormData对象，你可以使用一系列的键值对来模拟一个完整的表单，然后使用XMLHttpRequest发送表单.</p>
<ul>
<li>构造函数<br><code>new FormData (form? : HTMLFormElement)</code></li>
<li><p>参数</p>
<ul>
<li><code>form (可选)</code>:一个HTML表单元素,可以包含任何形式的表单控件,包括文件输入框.</li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li><p>append()</p>
<p>给当前FormData对象添加一个键/值对.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void append(DOMString name, Blob value, optional DOMString filename);</div><div class="line">void append(DOMString name, DOMString value);</div></pre></td></tr></table></figure>
</li>
<li><p>参数值<br><code>name</code>: 字段名称.<br><code>value</code>: 字段值.可以是,或者一个字符串,如果全都不是,则该值会被自动转换成字符串.<br><code>filename</code>(可选): 指定文件的文件名,当value参数被指定为一个Blob对象或者一个File对象时,该文件名会被发送到服务器上,对于Blob对象来说,这个值默认为<code>blob</code>.</p>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>你可以先创建一个空的FormData对象，然后使用append()方法向该对象里添加字段，实现demo如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var oMyForm = new FormData();</div><div class="line"></div><div class="line">oMyForm.append(&quot;username&quot;, &quot;Groucho&quot;);</div><div class="line">oMyForm.append(&quot;accountnum&quot;, 123456); // 数字123456被立即转换成字符串&quot;123456&quot;</div><div class="line"></div><div class="line">// fileInputElement中已经包含了用户所选择的文件</div><div class="line">oMyForm.append(&quot;userfile&quot;, fileInputElement.files[0]);</div><div class="line"></div><div class="line">var oFileBody = &apos;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&apos;; // Blob对象包含的文件内容</div><div class="line">var oBlob = new Blob([oFileBody], &#123; type: &quot;text/xml&quot;&#125;);</div><div class="line"></div><div class="line">oMyForm.append(&quot;webmasterfile&quot;, oBlob);</div><div class="line"></div><div class="line">var oReq = new XMLHttpRequest();</div><div class="line">oReq.open(&quot;POST&quot;, &quot;http://foo.com/submitform.php&quot;);</div><div class="line">oReq.send(oMyForm);</div></pre></td></tr></table></figure>
<blockquote>
<p>注: 字段<code>userfile</code>和<code>webmasterfile</code>的值都包含了一个文件。通过 <code>FormData.append()</code>方法赋给字段<code>accountnum</code>的数字被自动转换为字符(字段的值可以是一个Blob对象，一个File对象，或者一个字符串，剩下其他类型的值都会被自动转换成字符串)。</p>
</blockquote>
<p>在该例子中，我们创建了一个名为oMyForm的FormData对象，该对象中包含了名为<code>username</code>, <code>accountnum</code>, <code>userfile</code> 以及 <code>webmasterfile</code>的字段名，然后使用<code>XMLHttpRequest</code>的<code>send()</code>方法把这些数据发送了出去。<code>webmasterfile</code>字段的值不是一个字符串，还是一个Blob对象。</p>
<h2 id="HTML表单初始化FormData"><a href="#HTML表单初始化FormData" class="headerlink" title="HTML表单初始化FormData"></a>HTML表单初始化FormData</h2><p>可以用一个已有的<code>&lt;form&gt;</code>元素来初始化FormData对象,只需要把这个form元素作为参数传入FormData构造函数即可:</p>
<p><code>var newFormData = new FormData(someFormElement);</code></p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var formElement = document.getElementById(&quot;myFormElement&quot;);</div><div class="line">var oReq = new XMLHttpRequest();</div><div class="line">oReq.open(&quot;POST&quot;, &quot;submitform.php&quot;);</div><div class="line">oReq.send(new FormData(formElement));</div></pre></td></tr></table></figure>
<p>你还可以在已有表单数据的基础上,继续添加新的键值对,如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var formElement = document.getElementById(&quot;myFormElement&quot;);</div><div class="line">formData = new FormData(formElement);</div><div class="line">formData.append(&quot;serialnumber&quot;, serialNumber++);</div><div class="line">oReq.send(formData);</div></pre></td></tr></table></figure>
<p>你可以通过这种方式添加一些不想让用户编辑的固定字段,然后再发送.</p>
<h2 id="使用FormData发送文件"><a href="#使用FormData发送文件" class="headerlink" title="使用FormData发送文件"></a>使用FormData发送文件</h2><p>你还可以使用FormData来发送二进制文件.首先在HTML中要有一个包含了文件输入框的form元素:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; name=&quot;fileinfo&quot;&gt;</div><div class="line">  &lt;label&gt;Your email address:&lt;/label&gt;</div><div class="line">  &lt;input type=&quot;email&quot; autocomplete=&quot;on&quot; autofocus name=&quot;userid&quot; placeholder=&quot;email&quot; required size=&quot;32&quot; maxlength=&quot;64&quot; /&gt;&lt;br /&gt;</div><div class="line">  &lt;label&gt;Custom file label:&lt;/label&gt;</div><div class="line">  &lt;input type=&quot;text&quot; name=&quot;filelabel&quot; size=&quot;12&quot; maxlength=&quot;32&quot; /&gt;&lt;br /&gt;</div><div class="line">  &lt;label&gt;File to stash:&lt;/label&gt;</div><div class="line">  &lt;input type=&quot;file&quot; name=&quot;file&quot; required /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;div id=&quot;output&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;a href=&quot;javascript:sendForm()&quot;&gt;Stash the file!&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>然后你就可以使用下面的代码来异步的上传用户所选择的文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function sendForm() &#123;</div><div class="line">  var oOutput = document.getElementById(&quot;output&quot;);</div><div class="line">  var oData = new FormData(document.forms.namedItem(&quot;fileinfo&quot;));</div><div class="line"></div><div class="line">  oData.append(&quot;CustomField&quot;, &quot;This is some extra data&quot;);</div><div class="line"></div><div class="line">  var oReq = new XMLHttpRequest();</div><div class="line">  oReq.open(&quot;POST&quot;, &quot;stash.php&quot;, true);</div><div class="line">  oReq.onload = function(oEvent) &#123;</div><div class="line">    if (oReq.status == 200) &#123;</div><div class="line">      oOutput.innerHTML = &quot;Uploaded!&quot;;</div><div class="line">    &#125; else &#123;</div><div class="line">      oOutput.innerHTML = &quot;Error &quot; + oReq.status + &quot; occurred uploading your file.&lt;br \/&gt;&quot;;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  oReq.send(oData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你还可以不借助HTML表单,直接向FormData对象中添加一个File对象或者一个Blob对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.append(&quot;myfile&quot;, myBlob);</div></pre></td></tr></table></figure>
<p>如果FormData对象中的某个字段值是一个Blob对象，则在发送http请求时，代表该Blob对象所包含文件的文件名的<code>Content-Disposition</code>请求头的值在不同的浏览器下有所不同，Firefox使用了固定的字符串<code>blob</code>，而Chrome使用了一个随机字符串。</p>
<p>你还可以使用jQuery来发送FormData,但必须要正确的设置相关选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var fd = new FormData(document.getElementById(&quot;fileinfo&quot;));</div><div class="line">fd.append(&quot;CustomField&quot;, &quot;This is some extra data&quot;);</div><div class="line">$.ajax(&#123;</div><div class="line">  url: &quot;stash.php&quot;,</div><div class="line">  type: &quot;POST&quot;,</div><div class="line">  data: fd,</div><div class="line">  processData: false,  // 告诉jQuery不要去处理发送的数据</div><div class="line">  contentType: false   // 告诉jQuery不要去设置Content-Type请求头</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>注：不要显式地设置<code>contentType</code>为<code>multipart/form-data</code>。</p>
</blockquote>
<h2 id="FormData异步上传大文件"><a href="#FormData异步上传大文件" class="headerlink" title="FormData异步上传大文件"></a>FormData异步上传大文件</h2><p>下面给出一个完整的使用<code>FormData</code>以及<code>XMLHttpRequest</code>上传大文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head lang=&quot;en&quot;&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;大文件上传实例&lt;/title&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        const BYTES_PER_CHUNK = 1024 * 1024; // 每个文件切片大小定为1MB .</div><div class="line">        var slices;</div><div class="line">        var totalSlices;</div><div class="line"></div><div class="line">        //发送请求</div><div class="line">        function sendRequest() &#123;</div><div class="line"></div><div class="line">            var blob = document.getElementById(&apos;file&apos;).files[0];</div><div class="line"></div><div class="line">            var start = 0;</div><div class="line">            var end;</div><div class="line">            var index = 0;</div><div class="line"></div><div class="line">            // 计算文件切片总数</div><div class="line">            slices = Math.ceil(blob.size / BYTES_PER_CHUNK);</div><div class="line">            totalSlices= slices;</div><div class="line"></div><div class="line">            while(start &lt; blob.size) &#123;</div><div class="line">                end = start + BYTES_PER_CHUNK;</div><div class="line">                if(end &gt; blob.size) &#123;</div><div class="line">                    end = blob.size;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                uploadFile(blob, index, start, end);</div><div class="line"></div><div class="line">                start = end;</div><div class="line">                index++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //上传文件</div><div class="line">        function uploadFile(blob, index, start, end) &#123;</div><div class="line">            var xhr;</div><div class="line">            var fd;</div><div class="line">            var chunk;</div><div class="line"></div><div class="line">            xhr = new XMLHttpRequest();</div><div class="line">            xhr.onreadystatechange = function() &#123;</div><div class="line">                if(xhr.readyState == 4) &#123;</div><div class="line">                    if(xhr.responseText) &#123;</div><div class="line">                        alert(xhr.responseText);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    slices--;</div><div class="line"></div><div class="line">                    // 如果所有文件切片都成功发送，发送文件合并请求。</div><div class="line">                    if(slices == 0) &#123;</div><div class="line">                        mergeFile(blob);</div><div class="line">                        alert(&apos;文件上传完毕&apos;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line"></div><div class="line"></div><div class="line">            chunk =blob.slice(start,end);//切割文件</div><div class="line"></div><div class="line">            //构造form数据</div><div class="line">            fd = new FormData();</div><div class="line">            fd.append(&quot;file&quot;, chunk);</div><div class="line">            fd.append(&quot;name&quot;, blob.name);</div><div class="line">            fd.append(&quot;index&quot;, index);</div><div class="line"></div><div class="line">            xhr.open(&quot;POST&quot;, &quot;upload.php&quot;, true);</div><div class="line">            xhr.send(fd);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        function mergeFile(blob) &#123;</div><div class="line">            var xhr;</div><div class="line">            var fd;</div><div class="line"></div><div class="line">            xhr = new XMLHttpRequest();</div><div class="line"></div><div class="line">            fd = new FormData();</div><div class="line">            fd.append(&quot;name&quot;, blob.name);</div><div class="line">            fd.append(&quot;index&quot;, totalSlices);</div><div class="line"></div><div class="line">            xhr.open(&quot;POST&quot;, &quot;merge.php&quot;, true);</div><div class="line">            xhr.send(fd);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;input type=&quot;file&quot; id=&quot;file&quot;/&gt;</div><div class="line">&lt;button  onclick=&quot;sendRequest()&quot;&gt;上传&lt;/button&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<ul>
<li><code>upload.php</code>文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">//省略了文件接收判断isset部分</div><div class="line">//当前目录下建立一个uploads文件夹</div><div class="line">//接收文件名时进行转码，防止中文乱码。</div><div class="line">$target = &quot;uploads/&quot; .$_POST[&quot;name&quot;] . &apos;-&apos; . $_POST[&apos;index&apos;];</div><div class="line">move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;], $target);</div><div class="line"></div><div class="line">// Might execute too quickly.</div><div class="line">sleep(1);</div></pre></td></tr></table></figure>
<ul>
<li><code>merge.php</code>文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?php</div><div class="line">//文件合并</div><div class="line">$target = &quot;uploads/&quot; .iconv(&quot;utf-8&quot;,&quot;gbk&quot;,$_POST[&quot;name&quot;]);</div><div class="line">$dst = fopen($target, &apos;wb&apos;);</div><div class="line"></div><div class="line">for($i = 0; $i &lt; $_POST[&apos;index&apos;]; $i++) &#123;</div><div class="line">    $slice = $target . &apos;-&apos; . $i;</div><div class="line">    $src = fopen($slice,&apos;rb&apos;);</div><div class="line">    stream_copy_to_stream($src, $dst);</div><div class="line">    fclose($src);</div><div class="line">    unlink($slice);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fclose($dst);</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> HTTP协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> XMLHttpRequest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解Http协议之Content-Type]]></title>
      <url>/2016/11/06/%E7%90%86%E8%A7%A3HTTP%E4%B9%8BContent-Type/</url>
      <content type="html"><![CDATA[<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>发送Restful API工具：<a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?utm_source=chrome-ntp-icon" target="_blank" rel="external">Chrome插件POST Man</a></p>
<p>在HTTP 1.1规范中，HTTP请求方式有OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT</p>
<p>通常我们用的只有GET、POST，然而对于Restful API规范来说，请求资源要用PUT方法，删除资源要用DELETE方法。</p>
<p>例如发送个DELETE包：</p>
<p><code>http://example.com/my/resource?id=12345</code></p>
<p>那么通过id就能获取到信息，这个包只有header，并不存在body，下面讨论几个包含body的发包的body传输格式。</p>
<h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><p>Content-Type用于指定内容类型，一般是指网页中存在的Content-Type，Content-Type属性指定请求和响应的HTTP内容类型。如果未指定 ContentType，默认为text/html。</p>
<p>在nginx中有个配置文件mime.types，主要是标示Content-Type的文件格式。</p>
<a id="more"></a>
<p>下面是几个常见的Content-Type:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.text/html</div><div class="line">2.text/plain</div><div class="line">3.text/css</div><div class="line">4.text/javascript</div><div class="line">5.application/x-www-form-urlencoded</div><div class="line">6.multipart/form-data</div><div class="line">7.application/json</div><div class="line">8.application/xml</div><div class="line">...</div></pre></td></tr></table></figure>
<p>前面几个都很好理解，都是html，css，javascript的文件类型，后面四个是POST的发包方式。</p>
<h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h3><p>application/x-www-form-urlencoded是常用的表单发包方式，普通的表单提交，或者js发包，默认都是通过这种方式，</p>
<p>比如一个简单地表单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form enctype=&quot;application/x-www-form-urlencoded&quot; action=&quot;http://homeway.me/post.php&quot; method=&quot;POST&quot;&gt;</div><div class="line">	&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;homeway&quot;&gt;</div><div class="line">	&lt;input type=&quot;text&quot; name=&quot;key&quot; value=&quot;nokey&quot;&gt;</div><div class="line">	&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>那么服务器收到的raw header会类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</div><div class="line">Accept-Encoding:gzip, deflate</div><div class="line">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4,gl;q=0.2,de;q=0.2</div><div class="line">Cache-Control:no-cache</div><div class="line">Connection:keep-alive</div><div class="line">Content-Length:17</div><div class="line">Content-Type:application/x-www-form-urlencoded</div></pre></td></tr></table></figure>
<p>那么服务器收到的raw body会是，name=homeway&amp;key=nokey，在php中，通过$_POST就可以获得数组形式的数据。</p>
<h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>multipart/form-data用在发送文件的POST包。</p>
<p>这里假设我用python的request发送一个文件给服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">data = &#123;</div><div class="line">	&quot;key1&quot;: &quot;123&quot;,</div><div class="line">	&quot;key2&quot;: &quot;456&quot;,</div><div class="line">&#125;</div><div class="line">files = &#123;&apos;file&apos;: open(&apos;index.py&apos;, &apos;rb&apos;)&#125;</div><div class="line">res = requests.post(url=&quot;http://localhost/upload&quot;, method=&quot;POST&quot;, data=data, files=files)</div><div class="line">print res</div></pre></td></tr></table></figure>
<p>通过工具，可以看到我发送的数据内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">POST http://www.homeway.me HTTP/1.1</div><div class="line">Content-Type:multipart/form-data; boundary=------WebKitFormBoundaryOGkWPJsSaJCPWjZP</div><div class="line"></div><div class="line">------WebKitFormBoundaryOGkWPJsSaJCPWjZP</div><div class="line">Content-Disposition: form-data; name=&quot;key2&quot;</div><div class="line">456</div><div class="line">------WebKitFormBoundaryOGkWPJsSaJCPWjZP</div><div class="line">Content-Disposition: form-data; name=&quot;key1&quot;</div><div class="line">123</div><div class="line">------WebKitFormBoundaryOGkWPJsSaJCPWjZP</div><div class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;index.py&quot;</div></pre></td></tr></table></figure>
<p>这里Content-Type告诉我们，发包是以multipart/form-data格式来传输，另外，还有boundary用于分割数据。</p>
<p>当文件太长，HTTP无法在一个包之内发送完毕，就需要分割数据，分割成一个一个chunk发送给服务端，</p>
<p>那么–用于区分数据快，而后面的数据<code>633e61ebf351484f9124d63ce76d8469</code>就是标示区分包作用。</p>
<h3 id="text-xml"><a href="#text-xml" class="headerlink" title="text/xml"></a>text/xml</h3><p>微信用的是这种数据格式发送请求的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">POST http://www.homeway.me HTTP/1.1 </div><div class="line">Content-Type: text/xml</div><div class="line"></div><div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;resource&gt;</div><div class="line">    &lt;id&gt;123&lt;/id&gt;</div><div class="line">    &lt;params&gt;</div><div class="line">        &lt;name&gt;</div><div class="line">            &lt;value&gt;homeway&lt;/value&gt;</div><div class="line">        &lt;/name&gt;</div><div class="line">        &lt;age&gt;</div><div class="line">            &lt;value&gt;22&lt;/value&gt;</div><div class="line">        &lt;/age&gt;</div><div class="line">    &lt;/params&gt;</div><div class="line">&lt;/resource&gt;</div></pre></td></tr></table></figure>
<p>php中<code>$_POST</code>只能读取<code>application/x-www-form-urlencoded</code>数据，<code>$_FILES</code>只能读取<code>multipart/form-data</code>类型数据，</p>
<p>那么，要读取<code>text/xml</code>格式的数据，可以用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$file = fopen(‘php://input’, ‘rb’);</div><div class="line">$data = fread($file, length);</div><div class="line">fclose($file);</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$data = file_get_contents(‘php://input’);</div></pre></td></tr></table></figure></p>
<h3 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a>application/json</h3><p>通过json形式将数据发送给服务器，一开始，我尝试通过curl，给服务器发送application/json格式包，</p>
<p>然而我收到的数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">—————————————e1e1406176ee348a Content-Disposition: form-data; name=”nid” 2 —————————————e1e1406176ee348a Content-Disposition: form-data; name=”uuid” cf9dc994-a4e7-3ad6-bc54-41965b2a0dd7 —————————————e1e1406176ee348a Content-Disposition: form-data; name=”access_token” 956731586df41229dbfec08dd5d54eedb98d73d2 —————————————e1e1406176ee348a—</div></pre></td></tr></table></figure>
<p>后来想想明白了，HTTP通信中并不存在所谓的json，而是将string转成json罢了，也就是，<code>application/json</code>可以将它理解为<code>text/plain</code>，普通字符串。</p>
<p>之所以出现那么多乱七八糟的——-应该是php数组传输进去，存在的转换问题吧（我目前能想到的原因）。</p>
<ul>
<li>转自<a href="http://homeway.me/2015/07/19/understand-http-about-content-type/" target="_blank" rel="external">http://homeway.me/2015/07/19/understand-http-about-content-type/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTTP协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Content-Type </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac下iterm2替代secureCRT配置方法]]></title>
      <url>/2016/10/29/Mac%E4%B8%8BiTerm2%E6%9B%BF%E4%BB%A3secureCRT%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>最近在折腾iterm2的自动登录问题，由于之前一直在windows使用xshell作为我的ssh客户端，习惯了自动登录以及在远程机器上执行本地脚本（script），刚接触mac上iterm2很崩溃，虽然iterm2的分屏等操作极大方便了程序员的开发，但是日常经常通过跳板机登录线上机器，使我对于输入机器名密码登录很是头疼。xshell可以编辑快捷按钮并且自定义脚本方式达成目的，iterm2可是需要折腾一番。</p>
<h1 id="Session复制"><a href="#Session复制" class="headerlink" title="Session复制"></a>Session复制</h1><p>windows下xshell和secureCRT等ssh客户端有个很大的优势就是可以复制会话，可以不用重复输入机器密码。</p>
<p>ssh本身也提供了一种快捷的方式来解决这个问题，在 <code>~/.ssh/config</code> 文件中加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Host *</div><div class="line">ControlMaster auto</div><div class="line">ControlPath ~/.ssh/master-%r@%h:%p</div></pre></td></tr></table></figure>
<p>这样下次登录同一个站点时，即可复用之前的会话信息，我们可以在<code>~/.ssh/</code>目录看到<br><img src="/uploads/1942b8af4d43f54246c29abba.png" alt=""><br>这代表每次登录这个站点的时候其实是复用之前的会话句柄。</p>
<a id="more"></a>
<h1 id="登录远程机器"><a href="#登录远程机器" class="headerlink" title="登录远程机器"></a>登录远程机器</h1><p>登录远程机器通常有两种，一种是通过账号密码登录，另一种是基于密钥的安全认证，<code>ssh密钥认证自动登录</code>正是通过这种方式的安全认证，但是配置起来比较麻烦，这里不推荐，感兴趣的同学可以看这里<a href="https://segmentfault.com/a/1190000000481249" target="_blank" rel="external">配置ssh密钥认证自动登录</a>。下面我们介绍通过密码登录的配置方式。</p>
<h2 id="可以直连的机器"><a href="#可以直连的机器" class="headerlink" title="可以直连的机器"></a>可以直连的机器</h2><p>xshell和secureCRT另一个很方便的功能就是，我们可以将登录机器的信息保存并使用快捷操作（保存成脚本或快捷命令），这样每次登录机器时就不用敲一堆机器名密码，最头疼的是我们根本也记不住这些用户名密码，iterm2有没有相应的解决方案呢？答案是肯定的。</p>
<p>在 <code>~/.ssh/config</code> 文件中加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Host &lt;alias&gt;</div><div class="line">    Hostname &lt;ip&gt;/&lt;hostname&gt;</div><div class="line">    Port &lt;port&gt;</div><div class="line">    User &lt;username&gt;</div></pre></td></tr></table></figure>
<p>这样当我们输入<code>ssh alias</code>的时候，其实执行的是<code>ssh username@ip/hostname:port</code>，这样就很方便得登录到远程机器。</p>
<h2 id="无法直连的机器"><a href="#无法直连的机器" class="headerlink" title="无法直连的机器"></a>无法直连的机器</h2><p>大公司经常通过跳板机登录到目标机器上，为了安全考虑，我们是无法直接连接线上机器的，通过上面的方式无法解决我们的问题，那有没有其他方式呢？答案是有的，我们可以把这个问题分成两种情况：</p>
<h3 id="静态密码登录"><a href="#静态密码登录" class="headerlink" title="静态密码登录"></a>静态密码登录</h3><p>有些公司的跳板机是静态密码，也就是使用固定密码登录，可以分为以下几个步骤：</p>
<p>1.写一个简单的expect脚本，如<code>remote.exp</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect  </div><div class="line"></div><div class="line">set timeout 30 </div><div class="line"></div><div class="line"># 跳板机</div><div class="line">set jumphost relay01.baidu.com</div><div class="line">set jumppasswd root</div><div class="line">set jumpuser root</div><div class="line">set jumpport 22</div><div class="line"></div><div class="line"># 登录跳板机</div><div class="line">spawn ssh $jumpuser@$jumphost:$jumpport</div><div class="line"></div><div class="line"># expect输出信息请自定义，如不需要密码，下段可省略</div><div class="line">expect &#123;  </div><div class="line">    &quot;(yes/no)?&quot;  </div><div class="line">    &#123;send &quot;yes\r&quot;&#125;  </div><div class="line">    &quot;password:&quot;  </div><div class="line">    &#123;send &quot;$jumppasswd\r&quot;&#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"># 目标机器信息</div><div class="line">set host dev.baidu.com</div><div class="line">set passwd xxx</div><div class="line">set user xxx</div><div class="line">set port 22</div><div class="line"></div><div class="line"># 登录目标机器</div><div class="line">send &quot;ssh $user@$host:$port&quot;</div><div class="line"># expect输出信息请自定义，如不需要密码，下段可省略</div><div class="line">expect &#123;  </div><div class="line">    &quot;(yes/no)?&quot;  </div><div class="line">    &#123;send &quot;yes\r&quot;&#125;  </div><div class="line">    &quot;password:&quot;  </div><div class="line">    &#123;send &quot;passwd\r&quot;&#125;  </div><div class="line">&#125;</div><div class="line"># 结束控制</div><div class="line">interact</div></pre></td></tr></table></figure>
<p>提示： </p>
<ul>
<li>命令字符串结尾别忘记加上“\r”或“\n”，相当于回车</li>
<li>expect后根据自己机器的实际输出，定义判断字段</li>
</ul>
<p>2.将脚本复制到<code>~/.ssh</code>目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv remote.exp ~/.ssh</div></pre></td></tr></table></figure></p>
<p>3.设置调用命令</p>
<p>iTerm – preferences 打开设置界面，配置如下：<br><img src="/uploads/5f7b238a183ff66cf3b57342c.png" alt=""></p>
<h3 id="动态密码登录"><a href="#动态密码登录" class="headerlink" title="动态密码登录"></a>动态密码登录</h3><p>大公司中，使用动态密码登录跳板机的情况比较常见，动态密码一般是自己设置的6位密码+token的动态6位数字，这种方式看似复杂，其实我们可以通过两种情况看:</p>
<ol>
<li>已经通过动态密码登录过跳板机：【复制会话】会实现自动登录，配置方式同上；</li>
<li>有的同学比较任性，之前没有登陆过跳板机，能不能实现一次操作直接登录跳板机和目标机器呢？可以，但需要高阶一点的<code>expect</code>语法，写法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect</div><div class="line"></div><div class="line">set timeout 30</div><div class="line"></div><div class="line"># 跳板机</div><div class="line">set jumphost relay01.baidu.com</div><div class="line">set jumpuser root</div><div class="line">set jumpport 22</div><div class="line"></div><div class="line"># 登录跳板机</div><div class="line">spawn ssh $jumpuser@$jumphost:$jumpport</div><div class="line"></div><div class="line"># 目标机器信息</div><div class="line">set host dev.baidu.com</div><div class="line">set passwd xxx</div><div class="line">set user xxx</div><div class="line">set port 22</div><div class="line"></div><div class="line">interact &#123;</div><div class="line">    &quot;off&quot; &#123;</div><div class="line">        send &quot;ssh $user@$host:$port\n&quot;</div><div class="line">        # exec ssh $user@$host:$port</div><div class="line">        interact</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>提示：<code>off</code>为用户设置的远端机器的别名，登录跳板机后，输入“off”登录目标机器。</p>
<p>这种方式可能还不够优雅，下面介绍<strong>终极解决方案</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect</div><div class="line"></div><div class="line"># 跳板机</div><div class="line">set jumphost relay01</div><div class="line">set jumpuser xiashanshan</div><div class="line">set jumpport 22</div><div class="line"></div><div class="line"># grab the password</div><div class="line">stty -echo</div><div class="line">send_user -- &quot;Password for $jumpuser@$jumphost: &quot;</div><div class="line">expect_user -re &quot;(.*)\n&quot;</div><div class="line">send_user &quot;\n&quot;</div><div class="line">stty echo</div><div class="line"># set pass</div><div class="line">set pass $expect_out(1,string)</div><div class="line"></div><div class="line">#exec ssh $jumpuser@$jumphost</div><div class="line"></div><div class="line"># 登录跳板机</div><div class="line">spawn ssh $jumpuser@$jumphost</div><div class="line"></div><div class="line">expect &#123;</div><div class="line">    &quot;*password:*&quot; &#123; send &quot;$pass\n&quot; &#125;</div><div class="line">    &quot;*ssl*&quot; &#123; send &quot;\n&quot; &#125;</div><div class="line">    default &#123; exit 1 &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 目标机器信息</div><div class="line">set host idev.baidu.com</div><div class="line">set user root</div><div class="line">set password root</div><div class="line"></div><div class="line">send &quot;ssh --matrix $user@$host\n&quot;</div><div class="line"></div><div class="line">expect &#123;</div><div class="line">    &quot;*password:*&quot; &#123; send &quot;$pass\n&quot; &#125;</div><div class="line">    default &#123; exit 1 &#125;</div><div class="line">&#125;</div><div class="line">interact</div></pre></td></tr></table></figure>
<p>提示：如果已经登陆过跳板机，控制台输出<code>Password for $jumpuser@$jumphost:</code>提示输入密码时，可以直接回车跳过。</p>
<h1 id="rz、sz文件上传下载"><a href="#rz、sz文件上传下载" class="headerlink" title="rz、sz文件上传下载"></a>rz、sz文件上传下载</h1><p>首先需要安装<code>lrzsz</code>，如果没有安装<code>brew</code>，参考这里:<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">http://brew.sh/index_zh-cn.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install lrzsz</div></pre></td></tr></table></figure>
<p>然后下载iterm2-zmodem：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/bin</div><div class="line">wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh</div><div class="line">wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh</div></pre></td></tr></table></figure></p>
<p>打开<code>preferences → profiles</code>，选择某个profile，之后继续选择advanced → triggers，添加编辑添加如下triggers：</p>
<table>
<thead>
<tr>
<th>Regular Expression</th>
<th>Action</th>
<th>Parameters</th>
</tr>
</thead>
<tbody>
<tr>
<td>rz waiting to receive.**B0100</td>
<td>Run Silent Coprocess</td>
<td>/usr/local/bin/iterm2-send-zmodem.sh</td>
</tr>
<tr>
<td>**B00000000000000</td>
<td>Run Silent Coprocess</td>
<td>/usr/local/bin/iterm2-recv-zmodem.sh</td>
</tr>
</tbody>
</table>
<p><code>zmodem</code>原作者：<a href="https://github.com/mmastrac/iterm2-zmodem" target="_blank" rel="external">https://github.com/mmastrac/iterm2-zmodem</a></p>
<p>参考文章：<br>1.<a href="https://linux.die.net/man/1/expect" target="_blank" rel="external">https://linux.die.net/man/1/expect</a><br>2.<a href="https://www.pantz.org/software/expect/expect_examples_and_tips.html" target="_blank" rel="external">https://www.pantz.org/software/expect/expect_examples_and_tips.html</a></p>
]]></content>
      
        <categories>
            
            <category> Mac效率提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mac </tag>
            
            <tag> iTerm2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux awk命令详解]]></title>
      <url>/2016/05/15/Linux-awk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p>
<p>awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言：AWK 程序设计语言， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;pattern + action&#125;&apos; &#123;filenames&#125;</div></pre></td></tr></table></figure>
<p> 其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。<br> 通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</p>
<a id="more"></a>
<p>调用awk的命令行方式</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk [-F  field-separator]  &apos;commands&apos;  input-file(s)</div></pre></td></tr></table></figure>
<p>其中，commands 是真正awk命令，<strong>[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。<br>在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</strong></p>
<h1 id="awk入门实例"><a href="#awk入门实例" class="headerlink" title="awk入门实例"></a>awk入门实例</h1><p><strong>示例1</strong>：显示/etc/group所有group name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat group // group内容</div><div class="line">root:x:0:root</div><div class="line">bin:x:1:root,bin,daemon</div><div class="line">daemon:x:2:root,bin,daemon</div><div class="line">sys:x:3:root,bin,adm</div><div class="line">adm:x:4:root,adm,daemon</div><div class="line">tty:x:5:</div><div class="line">disk:x:6:root</div><div class="line">lp:x:7:daemon,lp</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ awk -F &apos;:&apos; &apos;BEGIN &#123;print &quot;start..&quot;&#125; &#123;print $1&#125; END &#123;print &quot;end..&quot;&#125;&apos; group</div><div class="line">start..</div><div class="line">root</div><div class="line">bin</div><div class="line">daemon</div><div class="line">sys</div><div class="line">adm</div><div class="line">tty</div><div class="line">disk</div><div class="line">lp</div><div class="line">end..</div></pre></td></tr></table></figure>
<p>awk工作流程是这样的：先执行BEGIN操作，然后读取文件，读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符（-F 指定）划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。随后开始执行模式所对应的动作action,接着开始读入第二条记录······直到所有的记录都读完，最后执行END操作。<br>默认域分隔符是tab，-F指定分隔符为‘:’，所以$1表示group名称，$3表示group包含的用户,以此类推。</p>
<p><strong>示例2</strong>：搜索/etc/group有root关键字的行并显示group name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ awk -F &apos;:&apos; &apos;/root/&#123;print $1&#125;&apos; group</div><div class="line">root</div><div class="line">bin</div><div class="line">daemon</div><div class="line">sys</div><div class="line">adm</div><div class="line">disk</div><div class="line">wheel</div></pre></td></tr></table></figure>
<p>这是pattern的使用示例，匹配了pattern(‘/root/‘)的行才会执行action(‘print $1’,没有指定action，默认输出每行的内容)。</p>
<p><em>搜索支持正则，例如查找 <code>root</code>开头的行 <code>awk &#39;/^root/&#39; /etc/group</code></em>。</p>
<h1 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h1><p>awk有许多内置变量，这些变量可以被改变，下面给出了一些最常用的变量。</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ARGC</td>
<td>命令行参数个数</td>
</tr>
<tr>
<td>ARGV</td>
<td>命令行参数排列</td>
</tr>
<tr>
<td>ENVIRON</td>
<td>支持队列中系统环境变量的使用</td>
</tr>
<tr>
<td>FILENAME</td>
<td>awk浏览的文件名</td>
</tr>
<tr>
<td>FNR</td>
<td>浏览文件的记录数</td>
</tr>
<tr>
<td>FS</td>
<td>设置输入域分隔符，等价于命令行 -F选项</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数</td>
</tr>
<tr>
<td>OFS</td>
<td>输出域分隔符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
<tr>
<td>RS</td>
<td>控制记录分隔符</td>
</tr>
</tbody>
</table>
<p>此外，$0变量是指整条记录，$1表示当前行的第一个域，$2表示当前行的第二个域，$NF表示当前行的最后一个域，以此类推。</p>
<p><strong>示例</strong>：统计/etc/group/每行的文件名、行号、每行的列数、每行的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ awk -F &apos;:&apos; &apos;&#123; print &quot;filename: &quot; FILENAME &quot;, lines: &quot; NR &quot;, columns: &quot; NF &quot;, &quot; $0 &#125;&apos; /etc/group</div><div class="line">filename: /etc/group, lines: 1, columns: 4, root:x:0:root</div><div class="line">filename: /etc/group, lines: 2, columns: 4, bin:x:1:root,bin,daemon</div><div class="line">filename: /etc/group, lines: 3, columns: 4, daemon:x:2:root,bin,daemon</div><div class="line">filename: /etc/group, lines: 4, columns: 4, sys:x:3:root,bin,adm</div><div class="line">filename: /etc/group, lines: 5, columns: 4, adm:x:4:root,adm,daemon</div><div class="line">filename: /etc/group, lines: 6, columns: 4, tty:x:5:</div><div class="line">filename: /etc/group, lines: 7, columns: 4, disk:x:6:root</div><div class="line">filename: /etc/group, lines: 8, columns: 4, lp:x:7:daemon,lp</div></pre></td></tr></table></figure>
<h1 id="awk编程"><a href="#awk编程" class="headerlink" title="awk编程"></a>awk编程</h1><h2 id="print和printf"><a href="#print和printf" class="headerlink" title="print和printf"></a>print和printf</h2><p>awk中同时提供了print和printf两种打印输出的函数。</p>
<p>其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。</p>
<p>printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。</p>
<p>上个示例使用<code>printf</code>替代<code>print</code>的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F &apos;:&apos; &apos;&#123; printf(&quot;filename: %10s, lines: %s, columns: %s, %s\n&quot;,FILENAME,NR,NF,$0) &#125;&apos; /etc/group</div></pre></td></tr></table></figure>
<h2 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h2><p>awk默认域分隔符是”tab”或者空格，使用-F指定分隔符，你可以同时指定多个分隔符，每个分隔符用’|’分割。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;a:b c,d&quot; | awk -F &quot; |,|:&quot; &apos;&#123;print $1; print $2; print $NF&#125;&apos;</div><div class="line">a</div><div class="line">b</div><div class="line">d</div></pre></td></tr></table></figure>
<h2 id="BEGIN、END用法"><a href="#BEGIN、END用法" class="headerlink" title="BEGIN、END用法"></a>BEGIN、END用法</h2><p>awk工作流程是这样的：先执行BEGIN操作，然后读取文件，读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符（-F 指定）划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。随后开始执行模式所对应的动作action,接着开始读入第二条记录···直到所有的记录都读完，最后执行END操作。</p>
<p><strong>示例1</strong>：有BEGIN有END：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ awk -F &apos;:&apos; &apos;BEGIN &#123;print &quot;start..&quot;&#125; &#123;print &quot;group name: &quot;$1; print &quot;group users: &quot;$3&#125; END &#123;print &quot;end..&quot;&#125;&apos; group</div><div class="line">start..</div><div class="line">group name: root</div><div class="line">group users: root</div><div class="line">group name: bin</div><div class="line">group users: root,bin,daemon</div><div class="line">group name: daemon</div><div class="line">group users: root,bin,daemon</div><div class="line">group name: sys</div><div class="line">group users: root,bin,adm</div><div class="line">group name: adm</div><div class="line">group users: root,adm,daemon</div><div class="line">....</div><div class="line">end..</div></pre></td></tr></table></figure>
<p><strong>示例2</strong>：只有END：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ awk -F &apos;:&apos; &apos;&#123;print &quot;start..&quot;&#125; &#123;print &quot;group name: &quot;$1; print &quot;group users: &quot;$3&#125; END &#123;print &quot;end..&quot;&#125;&apos; group</div><div class="line">start..</div><div class="line">group name: root</div><div class="line">group users: root</div><div class="line">start..</div><div class="line">group name: bin</div><div class="line">group users: root,bin,daemon</div><div class="line">start..</div><div class="line">group name: daemon</div><div class="line">group users: root,bin,daemon</div><div class="line">start..</div><div class="line">group name: sys</div><div class="line">group users: root,bin,adm</div><div class="line">start..</div><div class="line">group name: adm</div><div class="line">group users: root,adm,daemon</div><div class="line">....</div><div class="line">end..</div></pre></td></tr></table></figure></p>
<h2 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>因为awk中一维数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)，值和关键字都存储在key/value格式的hash表中。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。</p>
<p><strong>示例</strong>：我们要统计access_log日志每秒访问次数，并按倒序排：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ cat access_log </div><div class="line">  1 12/May/2016:02:53:51    &quot;GET /index&quot; </div><div class="line">  2 12/May/2016:02:53:50    &quot;GET /index&quot; </div><div class="line">  3 12/May/2016:02:53:50    &quot;GET /index&quot; </div><div class="line">  4 12/May/2016:02:52:51    &quot;GET /index&quot; </div><div class="line">  5 12/May/2016:02:52:51    &quot;GET /index&quot; </div><div class="line">  6 12/May/2016:02:53:51    &quot;GET /index&quot; </div><div class="line">  7 12/May/2016:02:52:51    &quot;GET /index&quot; </div><div class="line">  8 12/May/2016:02:52:51    &quot;GET /index&quot; </div><div class="line">  9 12/May/2016:02:53:49    &quot;GET /index&quot; </div><div class="line"> 10 12/May/2016:02:53:50    &quot;GET /index&quot; </div><div class="line"> 11 12/May/2016:02:43:51    &quot;GET /index&quot; </div><div class="line"> 12 12/May/2016:02:33:51    &quot;GET /index&quot; </div><div class="line"> 13 12/May/2016:02:53:49    &quot;GET /index&quot; </div><div class="line"> 14 12/May/2016:02:53:50    &quot;GET /index&quot; </div><div class="line"> 15 12/May/2016:02:53:50    &quot;GET /index&quot; </div><div class="line"> 16 12/May/2016:02:43:51    &quot;GET /index&quot; </div><div class="line"> 17 12/May/2016:02:53:51    &quot;GET /index&quot; </div><div class="line"> 18 12/May/2016:02:43:51    &quot;GET /index&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; counts[$2]++; &#125;; END&#123;for(time in counts) print counts[time] &quot; &quot; time&#125;&apos; access_log | sort -n</div><div class="line">1 12/May/2016:02:33:51</div><div class="line">2 12/May/2016:02:53:49</div><div class="line">3 12/May/2016:02:43:51</div><div class="line">3 12/May/2016:02:53:51</div><div class="line">4 12/May/2016:02:52:51</div><div class="line">5 12/May/2016:02:53:50</div></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>awk的多维数组的使用类似python中tuple数据结构，可以嵌套定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;BEGIN&#123; for(i=1;i&lt;=3;i++) &#123;for(j=1;j&lt;=3;j++) &#123;arr[i,j]=i*j; print i,&quot;*&quot;,j,&quot;=&quot;,arr[i,j]&#125;&#125;&#125;&apos;</div><div class="line">1 * 1 = 1</div><div class="line">1 * 2 = 2</div><div class="line">1 * 3 = 3</div><div class="line">2 * 1 = 2</div><div class="line">2 * 2 = 4</div><div class="line">2 * 3 = 6</div><div class="line">3 * 1 = 3</div><div class="line">3 * 2 = 6</div><div class="line">3 * 3 = 9</div></pre></td></tr></table></figure>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>awk的循环语句的写法和c语言中for、while、break、continue语法相同。</p>
<h2 id="awk内置函数"><a href="#awk内置函数" class="headerlink" title="awk内置函数"></a>awk内置函数</h2><ul>
<li><strong>int</strong>，把字符串转为整数</li>
<li><strong>index</strong>，查找字符串</li>
<li><strong>length</strong>，得到字符串、数组长度</li>
<li><strong>match</strong>，检测字符串1是否包含字符串2，包含则返回第一次出现的位置，否则返回0</li>
<li><strong>rand</strong>，生成随机数</li>
<li><strong>split</strong>，按照某个分隔符，对字符串进行切割，切割后的放到<code>thearray</code>中，返回分割后数组的长度</li>
<li><p><strong>sub</strong>，替换</p>
<blockquote>
<p>sub(a,b,s)，将s中出现的a字符串替换为b字符串</p>
</blockquote>
</li>
<li><p><strong>substr</strong>，字符串截取</p>
<blockquote>
<p>substr(s, m, n)     s是要截取的字符串，m是开始点，从1开始，n是要截取的长度</p>
</blockquote>
</li>
<li><p><strong>toupper</strong>，字符串转为大写</p>
</li>
<li><strong>tolower</strong>，字符串转为小写</li>
</ul>
]]></content>
      
        <categories>
            
            <category> linux命令详解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> awk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP字符集编码及函数解析]]></title>
      <url>/2016/05/13/PHP%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81%E5%8F%8A%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="php字符长度函数"><a href="#php字符长度函数" class="headerlink" title="php字符长度函数"></a>php字符长度函数</h1><blockquote>
<p>utf-8编码下中文3个字节，英文1个字节<br>gbk编码下中英文统一2个字节</p>
</blockquote>
<h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><p>返回给定的字符串 string 的字节长度。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$str = &apos;新人求脸熟&apos;;</div><div class="line">echo strlen($str).&quot;\n&quot;;</div><div class="line"></div><div class="line">print 15;</div></pre></td></tr></table></figure>
<p>引用 <a href="">strlen</a></p>
<a id="more"></a>
<h2 id="mb-strlen"><a href="#mb-strlen" class="headerlink" title="mb_strlen"></a>mb_strlen</h2><p>mixed mb_strlen ( string $str [, string $encoding = mb_internal_encoding() ] )<br>返回具有 encoding 编码的字符串 str 包含的字符数。 多字节的字符被计为 1。</p>
<p>文件编码：utf-8情况下<br>例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$str = &apos;新人求脸熟&apos;;</div><div class="line">echo mb_strlen($str).&quot;\n&quot;;</div><div class="line"></div><div class="line">print 5;</div></pre></td></tr></table></figure>
<p>例2 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$str = &apos;新人求脸熟&apos;;</div><div class="line">echo mb_strlen($str, &apos;gbk&apos;).&quot;\n&quot;;</div><div class="line"></div><div class="line">print 8;</div></pre></td></tr></table></figure>
<p>这是由于utf-8编码下，str包含5个汉字，占用15个字节，如果用gbk编码，则会返回15/2 = 8个字符长度。</p>
<p>引用 <a href="">mb_strlen</a></p>
<h1 id="php字符截取函数"><a href="#php字符截取函数" class="headerlink" title="php字符截取函数"></a>php字符截取函数</h1><p>待续…</p>
<!-- more -->
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="">阮一峰字符编码笔记</a></p>
]]></content>
      
        <categories>
            
            <category> 技术总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Windows下Zookeeper伪集群搭建]]></title>
      <url>/2016/05/13/Windows%E4%B8%8BZookeeper%E4%BC%AA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<h1 id="安装和配置详解"><a href="#安装和配置详解" class="headerlink" title="安装和配置详解"></a>安装和配置详解</h1><p>笔者使用的zookeeper版本是3.4.7，镜像下载地址<a href="http://apache.fayea.com/zookeeper/。" target="_blank" rel="external">http://apache.fayea.com/zookeeper/。</a><br>zookeeper的配置十分简单，下载之后解压缩。</p>
<p>ZOOKEEPER_HOME/conf/zoo.cnf<br>你可以直接复制zoo_sample.cfg，新建zoo.cfg文件，内容如下：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># The number of milliseconds of each tick 心跳间隔，单位毫秒</div><div class="line">tickTime=2000</div><div class="line"># The number of ticks that the initial </div><div class="line"># synchronization phase can take 初始同步阶段发送的心跳检测数</div><div class="line">initLimit=10 </div><div class="line"># The number of ticks that can pass between </div><div class="line"># sending a request and getting an acknowledgement 发送和接收间隔的心跳数</div><div class="line">syncLimit=5</div><div class="line"># the directory where the snapshot is stored.</div><div class="line"># do not use /tmp for storage, /tmp here is just </div><div class="line"># example sakes. 快照数据位置</div><div class="line">dataDir=D:\Tools\zookeeper-3.4.7\data</div><div class="line"># the port at which the clients will connect</div><div class="line">clientPort=2181</div><div class="line"># the maximum number of client connections.</div><div class="line"># increase this if you need to handle more clients 客户端连接的端口</div><div class="line">#maxClientCnxns=60</div><div class="line">#</div><div class="line"># Be sure to read the maintenance section of the </div><div class="line"># administrator guide before turning on autopurge.</div><div class="line">#</div><div class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</div><div class="line">#</div><div class="line"># The number of snapshots to retain in dataDir</div><div class="line">#autopurge.snapRetainCount=3</div><div class="line"># Purge task interval in hours</div><div class="line"># Set to &quot;0&quot; to disable auto purge feature</div><div class="line">#autopurge.purgeInterval=1</div></pre></td></tr></table></figure>
<p>启动Zookeeper<br>进入到bin目录，Shift+右键打开命令窗口，输入zkServer.cmd启动</p>
<h1 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h1><p>…</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1>]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Zookeeper </tag>
            
            <tag> Apache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python反转list/array/tuple]]></title>
      <url>/2016/05/13/Python%E5%8F%8D%E8%BD%AClist-array-tuple/</url>
      <content type="html"><![CDATA[<p>python有两种方式反转列表：</p>
<h2 id="list内置方法"><a href="#list内置方法" class="headerlink" title="list内置方法"></a>list内置方法</h2><p>list.reverse()</p>
<p>参考：<a href="https://docs.python.org/release/2.3.5/whatsnew/section-slices.html" target="_blank" rel="external">https://docs.python.org/release/2.3.5/whatsnew/section-slices.html</a></p>
]]></content>
      
        <categories>
            
            <category> 技术总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
